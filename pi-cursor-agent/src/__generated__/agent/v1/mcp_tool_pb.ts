// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file agent/v1/mcp_tool.proto (package agent.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { OutputLocation } from "./utils_pb.js";

/**
 * @generated from message agent.v1.McpToolError
 */
export class McpToolError extends Message<McpToolError> {
  /**
   * @generated from field: string error = 1;
   */
  error = "";

  constructor(data?: PartialMessage<McpToolError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.McpToolError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): McpToolError {
    return new McpToolError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): McpToolError {
    return new McpToolError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): McpToolError {
    return new McpToolError().fromJsonString(jsonString, options);
  }

  static equals(a: McpToolError | PlainMessage<McpToolError> | undefined, b: McpToolError | PlainMessage<McpToolError> | undefined): boolean {
    return proto3.util.equals(McpToolError, a, b);
  }
}

/**
 * @generated from message agent.v1.McpToolResult
 */
export class McpToolResult extends Message<McpToolResult> {
  /**
   * @generated from oneof agent.v1.McpToolResult.result
   */
  result: {
    /**
     * @generated from field: agent.v1.McpSuccess success = 1;
     */
    value: McpSuccess;
    case: "success";
  } | {
    /**
     * @generated from field: agent.v1.McpToolError error = 2;
     */
    value: McpToolError;
    case: "error";
  } | {
    /**
     * @generated from field: agent.v1.McpRejected rejected = 3;
     */
    value: McpRejected;
    case: "rejected";
  } | {
    /**
     * @generated from field: agent.v1.McpPermissionDenied permission_denied = 4;
     */
    value: McpPermissionDenied;
    case: "permissionDenied";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<McpToolResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.McpToolResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "message", T: McpSuccess, oneof: "result" },
    { no: 2, name: "error", kind: "message", T: McpToolError, oneof: "result" },
    { no: 3, name: "rejected", kind: "message", T: McpRejected, oneof: "result" },
    { no: 4, name: "permission_denied", kind: "message", T: McpPermissionDenied, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): McpToolResult {
    return new McpToolResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): McpToolResult {
    return new McpToolResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): McpToolResult {
    return new McpToolResult().fromJsonString(jsonString, options);
  }

  static equals(a: McpToolResult | PlainMessage<McpToolResult> | undefined, b: McpToolResult | PlainMessage<McpToolResult> | undefined): boolean {
    return proto3.util.equals(McpToolResult, a, b);
  }
}

/**
 * @generated from message agent.v1.McpToolCall
 */
export class McpToolCall extends Message<McpToolCall> {
  /**
   * @generated from field: agent.v1.McpArgs args = 1;
   */
  args?: McpArgs;

  /**
   * @generated from field: agent.v1.McpToolResult result = 2;
   */
  result?: McpToolResult;

  constructor(data?: PartialMessage<McpToolCall>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.McpToolCall";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "args", kind: "message", T: McpArgs },
    { no: 2, name: "result", kind: "message", T: McpToolResult },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): McpToolCall {
    return new McpToolCall().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): McpToolCall {
    return new McpToolCall().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): McpToolCall {
    return new McpToolCall().fromJsonString(jsonString, options);
  }

  static equals(a: McpToolCall | PlainMessage<McpToolCall> | undefined, b: McpToolCall | PlainMessage<McpToolCall> | undefined): boolean {
    return proto3.util.equals(McpToolCall, a, b);
  }
}

/**
 * @generated from message agent.v1.McpArgs
 */
export class McpArgs extends Message<McpArgs> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: map<string, bytes> args = 2;
   */
  args: { [key: string]: Uint8Array } = {};

  /**
   * @generated from field: string tool_call_id = 3;
   */
  toolCallId = "";

  /**
   * @generated from field: string provider_identifier = 4;
   */
  providerIdentifier = "";

  /**
   * @generated from field: string tool_name = 5;
   */
  toolName = "";

  constructor(data?: PartialMessage<McpArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.McpArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "args", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 12 /* ScalarType.BYTES */} },
    { no: 3, name: "tool_call_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "provider_identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "tool_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): McpArgs {
    return new McpArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): McpArgs {
    return new McpArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): McpArgs {
    return new McpArgs().fromJsonString(jsonString, options);
  }

  static equals(a: McpArgs | PlainMessage<McpArgs> | undefined, b: McpArgs | PlainMessage<McpArgs> | undefined): boolean {
    return proto3.util.equals(McpArgs, a, b);
  }
}

/**
 * @generated from message agent.v1.McpResult
 */
export class McpResult extends Message<McpResult> {
  /**
   * @generated from oneof agent.v1.McpResult.result
   */
  result: {
    /**
     * @generated from field: agent.v1.McpSuccess success = 1;
     */
    value: McpSuccess;
    case: "success";
  } | {
    /**
     * @generated from field: agent.v1.McpError error = 2;
     */
    value: McpError;
    case: "error";
  } | {
    /**
     * @generated from field: agent.v1.McpRejected rejected = 3;
     */
    value: McpRejected;
    case: "rejected";
  } | {
    /**
     * @generated from field: agent.v1.McpPermissionDenied permission_denied = 4;
     */
    value: McpPermissionDenied;
    case: "permissionDenied";
  } | {
    /**
     * @generated from field: agent.v1.McpToolNotFound tool_not_found = 5;
     */
    value: McpToolNotFound;
    case: "toolNotFound";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<McpResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.McpResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "message", T: McpSuccess, oneof: "result" },
    { no: 2, name: "error", kind: "message", T: McpError, oneof: "result" },
    { no: 3, name: "rejected", kind: "message", T: McpRejected, oneof: "result" },
    { no: 4, name: "permission_denied", kind: "message", T: McpPermissionDenied, oneof: "result" },
    { no: 5, name: "tool_not_found", kind: "message", T: McpToolNotFound, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): McpResult {
    return new McpResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): McpResult {
    return new McpResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): McpResult {
    return new McpResult().fromJsonString(jsonString, options);
  }

  static equals(a: McpResult | PlainMessage<McpResult> | undefined, b: McpResult | PlainMessage<McpResult> | undefined): boolean {
    return proto3.util.equals(McpResult, a, b);
  }
}

/**
 * @generated from message agent.v1.McpToolNotFound
 */
export class McpToolNotFound extends Message<McpToolNotFound> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: repeated string available_tools = 2;
   */
  availableTools: string[] = [];

  constructor(data?: PartialMessage<McpToolNotFound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.McpToolNotFound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "available_tools", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): McpToolNotFound {
    return new McpToolNotFound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): McpToolNotFound {
    return new McpToolNotFound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): McpToolNotFound {
    return new McpToolNotFound().fromJsonString(jsonString, options);
  }

  static equals(a: McpToolNotFound | PlainMessage<McpToolNotFound> | undefined, b: McpToolNotFound | PlainMessage<McpToolNotFound> | undefined): boolean {
    return proto3.util.equals(McpToolNotFound, a, b);
  }
}

/**
 * @generated from message agent.v1.McpTextContent
 */
export class McpTextContent extends Message<McpTextContent> {
  /**
   * @generated from field: string text = 1;
   */
  text = "";

  /**
   * @generated from field: optional agent.v1.OutputLocation output_location = 2;
   */
  outputLocation?: OutputLocation;

  constructor(data?: PartialMessage<McpTextContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.McpTextContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "output_location", kind: "message", T: OutputLocation, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): McpTextContent {
    return new McpTextContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): McpTextContent {
    return new McpTextContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): McpTextContent {
    return new McpTextContent().fromJsonString(jsonString, options);
  }

  static equals(a: McpTextContent | PlainMessage<McpTextContent> | undefined, b: McpTextContent | PlainMessage<McpTextContent> | undefined): boolean {
    return proto3.util.equals(McpTextContent, a, b);
  }
}

/**
 * @generated from message agent.v1.McpImageContent
 */
export class McpImageContent extends Message<McpImageContent> {
  /**
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  /**
   * @generated from field: string mime_type = 2;
   */
  mimeType = "";

  constructor(data?: PartialMessage<McpImageContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.McpImageContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "mime_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): McpImageContent {
    return new McpImageContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): McpImageContent {
    return new McpImageContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): McpImageContent {
    return new McpImageContent().fromJsonString(jsonString, options);
  }

  static equals(a: McpImageContent | PlainMessage<McpImageContent> | undefined, b: McpImageContent | PlainMessage<McpImageContent> | undefined): boolean {
    return proto3.util.equals(McpImageContent, a, b);
  }
}

/**
 * @generated from message agent.v1.McpToolResultContentItem
 */
export class McpToolResultContentItem extends Message<McpToolResultContentItem> {
  /**
   * @generated from oneof agent.v1.McpToolResultContentItem.content
   */
  content: {
    /**
     * @generated from field: agent.v1.McpTextContent text = 1;
     */
    value: McpTextContent;
    case: "text";
  } | {
    /**
     * @generated from field: agent.v1.McpImageContent image = 2;
     */
    value: McpImageContent;
    case: "image";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<McpToolResultContentItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.McpToolResultContentItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "message", T: McpTextContent, oneof: "content" },
    { no: 2, name: "image", kind: "message", T: McpImageContent, oneof: "content" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): McpToolResultContentItem {
    return new McpToolResultContentItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): McpToolResultContentItem {
    return new McpToolResultContentItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): McpToolResultContentItem {
    return new McpToolResultContentItem().fromJsonString(jsonString, options);
  }

  static equals(a: McpToolResultContentItem | PlainMessage<McpToolResultContentItem> | undefined, b: McpToolResultContentItem | PlainMessage<McpToolResultContentItem> | undefined): boolean {
    return proto3.util.equals(McpToolResultContentItem, a, b);
  }
}

/**
 * @generated from message agent.v1.McpSuccess
 */
export class McpSuccess extends Message<McpSuccess> {
  /**
   * @generated from field: repeated agent.v1.McpToolResultContentItem content = 1;
   */
  content: McpToolResultContentItem[] = [];

  /**
   * @generated from field: bool is_error = 2;
   */
  isError = false;

  constructor(data?: PartialMessage<McpSuccess>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.McpSuccess";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content", kind: "message", T: McpToolResultContentItem, repeated: true },
    { no: 2, name: "is_error", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): McpSuccess {
    return new McpSuccess().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): McpSuccess {
    return new McpSuccess().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): McpSuccess {
    return new McpSuccess().fromJsonString(jsonString, options);
  }

  static equals(a: McpSuccess | PlainMessage<McpSuccess> | undefined, b: McpSuccess | PlainMessage<McpSuccess> | undefined): boolean {
    return proto3.util.equals(McpSuccess, a, b);
  }
}

/**
 * @generated from message agent.v1.McpError
 */
export class McpError extends Message<McpError> {
  /**
   * @generated from field: string error = 1;
   */
  error = "";

  constructor(data?: PartialMessage<McpError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.McpError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): McpError {
    return new McpError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): McpError {
    return new McpError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): McpError {
    return new McpError().fromJsonString(jsonString, options);
  }

  static equals(a: McpError | PlainMessage<McpError> | undefined, b: McpError | PlainMessage<McpError> | undefined): boolean {
    return proto3.util.equals(McpError, a, b);
  }
}

/**
 * @generated from message agent.v1.McpRejected
 */
export class McpRejected extends Message<McpRejected> {
  /**
   * @generated from field: string reason = 1;
   */
  reason = "";

  /**
   * @generated from field: bool is_readonly = 2;
   */
  isReadonly = false;

  constructor(data?: PartialMessage<McpRejected>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.McpRejected";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_readonly", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): McpRejected {
    return new McpRejected().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): McpRejected {
    return new McpRejected().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): McpRejected {
    return new McpRejected().fromJsonString(jsonString, options);
  }

  static equals(a: McpRejected | PlainMessage<McpRejected> | undefined, b: McpRejected | PlainMessage<McpRejected> | undefined): boolean {
    return proto3.util.equals(McpRejected, a, b);
  }
}

/**
 * @generated from message agent.v1.McpPermissionDenied
 */
export class McpPermissionDenied extends Message<McpPermissionDenied> {
  /**
   * @generated from field: string error = 1;
   */
  error = "";

  /**
   * @generated from field: bool is_readonly = 2;
   */
  isReadonly = false;

  constructor(data?: PartialMessage<McpPermissionDenied>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.McpPermissionDenied";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_readonly", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): McpPermissionDenied {
    return new McpPermissionDenied().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): McpPermissionDenied {
    return new McpPermissionDenied().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): McpPermissionDenied {
    return new McpPermissionDenied().fromJsonString(jsonString, options);
  }

  static equals(a: McpPermissionDenied | PlainMessage<McpPermissionDenied> | undefined, b: McpPermissionDenied | PlainMessage<McpPermissionDenied> | undefined): boolean {
    return proto3.util.equals(McpPermissionDenied, a, b);
  }
}

