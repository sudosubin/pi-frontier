// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file agent/v1/read_tool.proto (package agent.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message agent.v1.ReadToolCall
 */
export class ReadToolCall extends Message<ReadToolCall> {
  /**
   * @generated from field: agent.v1.ReadToolArgs args = 1;
   */
  args?: ReadToolArgs;

  /**
   * @generated from field: agent.v1.ReadToolResult result = 2;
   */
  result?: ReadToolResult;

  constructor(data?: PartialMessage<ReadToolCall>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.ReadToolCall";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "args", kind: "message", T: ReadToolArgs },
    { no: 2, name: "result", kind: "message", T: ReadToolResult },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadToolCall {
    return new ReadToolCall().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadToolCall {
    return new ReadToolCall().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadToolCall {
    return new ReadToolCall().fromJsonString(jsonString, options);
  }

  static equals(a: ReadToolCall | PlainMessage<ReadToolCall> | undefined, b: ReadToolCall | PlainMessage<ReadToolCall> | undefined): boolean {
    return proto3.util.equals(ReadToolCall, a, b);
  }
}

/**
 * @generated from message agent.v1.ReadToolArgs
 */
export class ReadToolArgs extends Message<ReadToolArgs> {
  /**
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * @generated from field: optional int32 offset = 2;
   */
  offset?: number;

  /**
   * @generated from field: optional int32 limit = 3;
   */
  limit?: number;

  /**
   * @generated from field: optional bool include_line_numbers = 5;
   */
  includeLineNumbers?: boolean;

  constructor(data?: PartialMessage<ReadToolArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.ReadToolArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "offset", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: "include_line_numbers", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadToolArgs {
    return new ReadToolArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadToolArgs {
    return new ReadToolArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadToolArgs {
    return new ReadToolArgs().fromJsonString(jsonString, options);
  }

  static equals(a: ReadToolArgs | PlainMessage<ReadToolArgs> | undefined, b: ReadToolArgs | PlainMessage<ReadToolArgs> | undefined): boolean {
    return proto3.util.equals(ReadToolArgs, a, b);
  }
}

/**
 * @generated from message agent.v1.ReadToolResult
 */
export class ReadToolResult extends Message<ReadToolResult> {
  /**
   * @generated from oneof agent.v1.ReadToolResult.result
   */
  result: {
    /**
     * @generated from field: agent.v1.ReadToolSuccess success = 1;
     */
    value: ReadToolSuccess;
    case: "success";
  } | {
    /**
     * @generated from field: agent.v1.ReadToolError error = 2;
     */
    value: ReadToolError;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ReadToolResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.ReadToolResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "message", T: ReadToolSuccess, oneof: "result" },
    { no: 2, name: "error", kind: "message", T: ReadToolError, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadToolResult {
    return new ReadToolResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadToolResult {
    return new ReadToolResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadToolResult {
    return new ReadToolResult().fromJsonString(jsonString, options);
  }

  static equals(a: ReadToolResult | PlainMessage<ReadToolResult> | undefined, b: ReadToolResult | PlainMessage<ReadToolResult> | undefined): boolean {
    return proto3.util.equals(ReadToolResult, a, b);
  }
}

/**
 * @generated from message agent.v1.ReadRange
 */
export class ReadRange extends Message<ReadRange> {
  /**
   * @generated from field: uint32 start_line = 1;
   */
  startLine = 0;

  /**
   * @generated from field: uint32 end_line = 2;
   */
  endLine = 0;

  constructor(data?: PartialMessage<ReadRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.ReadRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_line", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "end_line", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadRange {
    return new ReadRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadRange {
    return new ReadRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadRange {
    return new ReadRange().fromJsonString(jsonString, options);
  }

  static equals(a: ReadRange | PlainMessage<ReadRange> | undefined, b: ReadRange | PlainMessage<ReadRange> | undefined): boolean {
    return proto3.util.equals(ReadRange, a, b);
  }
}

/**
 * @generated from message agent.v1.ReadToolSuccess
 */
export class ReadToolSuccess extends Message<ReadToolSuccess> {
  /**
   * @generated from field: bool is_empty = 2;
   */
  isEmpty = false;

  /**
   * @generated from field: bool exceeded_limit = 3;
   */
  exceededLimit = false;

  /**
   * @generated from field: uint32 total_lines = 4;
   */
  totalLines = 0;

  /**
   * @generated from field: uint32 file_size = 5;
   */
  fileSize = 0;

  /**
   * @generated from field: string path = 7;
   */
  path = "";

  /**
   * @generated from field: optional agent.v1.ReadRange read_range = 8;
   */
  readRange?: ReadRange;

  /**
   * @generated from oneof agent.v1.ReadToolSuccess.output
   */
  output: {
    /**
     * @generated from field: string content = 1;
     */
    value: string;
    case: "content";
  } | {
    /**
     * @generated from field: bytes data = 6;
     */
    value: Uint8Array;
    case: "data";
  } | {
    /**
     * @generated from field: bytes data_blob_id = 9;
     */
    value: Uint8Array;
    case: "dataBlobId";
  } | {
    /**
     * @generated from field: bytes content_blob_id = 10;
     */
    value: Uint8Array;
    case: "contentBlobId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: optional bool include_line_numbers = 11;
   */
  includeLineNumbers?: boolean;

  constructor(data?: PartialMessage<ReadToolSuccess>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.ReadToolSuccess";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "is_empty", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "exceeded_limit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "total_lines", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "file_size", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "read_range", kind: "message", T: ReadRange, opt: true },
    { no: 1, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "output" },
    { no: 6, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "output" },
    { no: 9, name: "data_blob_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "output" },
    { no: 10, name: "content_blob_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "output" },
    { no: 11, name: "include_line_numbers", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadToolSuccess {
    return new ReadToolSuccess().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadToolSuccess {
    return new ReadToolSuccess().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadToolSuccess {
    return new ReadToolSuccess().fromJsonString(jsonString, options);
  }

  static equals(a: ReadToolSuccess | PlainMessage<ReadToolSuccess> | undefined, b: ReadToolSuccess | PlainMessage<ReadToolSuccess> | undefined): boolean {
    return proto3.util.equals(ReadToolSuccess, a, b);
  }
}

/**
 * @generated from message agent.v1.ReadToolError
 */
export class ReadToolError extends Message<ReadToolError> {
  /**
   * @generated from field: string error_message = 1;
   */
  errorMessage = "";

  constructor(data?: PartialMessage<ReadToolError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.ReadToolError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadToolError {
    return new ReadToolError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadToolError {
    return new ReadToolError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadToolError {
    return new ReadToolError().fromJsonString(jsonString, options);
  }

  static equals(a: ReadToolError | PlainMessage<ReadToolError> | undefined, b: ReadToolError | PlainMessage<ReadToolError> | undefined): boolean {
    return proto3.util.equals(ReadToolError, a, b);
  }
}

