// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file agent/v1/fetch_tool.proto (package agent.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message agent.v1.FetchToolCall
 */
export class FetchToolCall extends Message<FetchToolCall> {
  /**
   * @generated from field: agent.v1.FetchArgs args = 1;
   */
  args?: FetchArgs;

  /**
   * @generated from field: agent.v1.FetchResult result = 2;
   */
  result?: FetchResult;

  constructor(data?: PartialMessage<FetchToolCall>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.FetchToolCall";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "args", kind: "message", T: FetchArgs },
    { no: 2, name: "result", kind: "message", T: FetchResult },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchToolCall {
    return new FetchToolCall().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchToolCall {
    return new FetchToolCall().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchToolCall {
    return new FetchToolCall().fromJsonString(jsonString, options);
  }

  static equals(a: FetchToolCall | PlainMessage<FetchToolCall> | undefined, b: FetchToolCall | PlainMessage<FetchToolCall> | undefined): boolean {
    return proto3.util.equals(FetchToolCall, a, b);
  }
}

/**
 * @generated from message agent.v1.FetchArgs
 */
export class FetchArgs extends Message<FetchArgs> {
  /**
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * @generated from field: string tool_call_id = 2;
   */
  toolCallId = "";

  constructor(data?: PartialMessage<FetchArgs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.FetchArgs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tool_call_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchArgs {
    return new FetchArgs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchArgs {
    return new FetchArgs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchArgs {
    return new FetchArgs().fromJsonString(jsonString, options);
  }

  static equals(a: FetchArgs | PlainMessage<FetchArgs> | undefined, b: FetchArgs | PlainMessage<FetchArgs> | undefined): boolean {
    return proto3.util.equals(FetchArgs, a, b);
  }
}

/**
 * @generated from message agent.v1.FetchResult
 */
export class FetchResult extends Message<FetchResult> {
  /**
   * @generated from oneof agent.v1.FetchResult.result
   */
  result: {
    /**
     * @generated from field: agent.v1.FetchSuccess success = 1;
     */
    value: FetchSuccess;
    case: "success";
  } | {
    /**
     * @generated from field: agent.v1.FetchError error = 2;
     */
    value: FetchError;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<FetchResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.FetchResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "message", T: FetchSuccess, oneof: "result" },
    { no: 2, name: "error", kind: "message", T: FetchError, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchResult {
    return new FetchResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchResult {
    return new FetchResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchResult {
    return new FetchResult().fromJsonString(jsonString, options);
  }

  static equals(a: FetchResult | PlainMessage<FetchResult> | undefined, b: FetchResult | PlainMessage<FetchResult> | undefined): boolean {
    return proto3.util.equals(FetchResult, a, b);
  }
}

/**
 * @generated from message agent.v1.FetchSuccess
 */
export class FetchSuccess extends Message<FetchSuccess> {
  /**
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * @generated from field: string content = 2;
   */
  content = "";

  /**
   * @generated from field: int32 status_code = 3;
   */
  statusCode = 0;

  /**
   * @generated from field: string content_type = 4;
   */
  contentType = "";

  constructor(data?: PartialMessage<FetchSuccess>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.FetchSuccess";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "status_code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "content_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchSuccess {
    return new FetchSuccess().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchSuccess {
    return new FetchSuccess().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchSuccess {
    return new FetchSuccess().fromJsonString(jsonString, options);
  }

  static equals(a: FetchSuccess | PlainMessage<FetchSuccess> | undefined, b: FetchSuccess | PlainMessage<FetchSuccess> | undefined): boolean {
    return proto3.util.equals(FetchSuccess, a, b);
  }
}

/**
 * @generated from message agent.v1.FetchError
 */
export class FetchError extends Message<FetchError> {
  /**
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * @generated from field: string error = 2;
   */
  error = "";

  constructor(data?: PartialMessage<FetchError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "agent.v1.FetchError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchError {
    return new FetchError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchError {
    return new FetchError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchError {
    return new FetchError().fromJsonString(jsonString, options);
  }

  static equals(a: FetchError | PlainMessage<FetchError> | undefined, b: FetchError | PlainMessage<FetchError> | undefined): boolean {
    return proto3.util.equals(FetchError, a, b);
  }
}

